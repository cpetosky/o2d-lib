package net.petosky.display {	import flash.display.DisplayObject;		import flash.events.Event;			import net.petosky.util.DisplayUtils;			/**	 * A spiral view displays its contents in a clockwise spiral. Any number	 * of display objects may be placed in a spiral view -- each successive 	 * object will be placed at the next position in the spiral.	 * 	 * A spiral view uses a modified positive arm of an Archimedean spiral. In	 * parametric form, an Archimedean spiral is defined by	 * 	 * x = a * theta * cos(theta)	 * y = a * theta * sin(theta)	 * 	 * A SpiralView uses a second constant factor, so that x and y can be	 * modified by different amounts:	 * 	 * x = a * theta * cos(theta)	 * y = b * theta * sin(theta)	 * 	 * These constants are represented by the properties xStretch and yStretch.	 * 	 * If we consider the Archimedean spiral to be a "circular spiral," the	 * spiral generated by this class is an "elliptical" spiral. Considered 	 * this way, xStretch is the semimajor axis and yStretch is the semiminor	 * axis of the ellipse implied by the spiral when theta = 1.	 * 	 * Note that if xStretch and yStretch are equal, this class generates an	 * Archimedean spiral.	 * 	 * Display objects added to this class are placed at discrete points along	 * the spiral arm. These points are determined by the supplied arc length.	 * This arc length represents the distance along the implied ellipse at	 * a particular theta we would travel to place the next display object. The	 * angle theta is then incremented by the correct amount to reach this point.	 * 	 * Note that this estimation of arc length is only meaningful when the arc	 * length is less than about half the circumference of the currently	 * implied ellipse. Any larger than that and items will not be evenly	 * spaced. Since the implied ellipses grow as the angle theta increases, this	 * is usually only visible for the first couple revolutions of the spiral.  	 * 	 * @author cpetosky	 */	public class SpiralView extends BaseListView {		private static const TWO_PI:Number = 2 * Math.PI;				private var _xStretch:Number = 1;		private var _yStretch:Number = 1;				private var _arcLength:Number;				private var _drawFirstInCenter:Boolean = true;		private var _startingAngle:Number = Math.PI;				private var _jitterer:Function;				public function SpiralView(arcLength:Number, xStretch:Number = 1, yStretch:Number = 1) {			_arcLength = arcLength;						_xStretch = xStretch;			_yStretch = yStretch;						addEventListener(Event.ADDED_TO_STAGE, stageListener, false, 50, true);		}		private function stageListener(event:Event):void {			DisplayUtils.fixRegistrationPoint(this);		}		override protected function initialize():void {			clearChildren();						var d:DisplayObject;			var theta:Number = _startingAngle;									// Draw first display object in center if appropriate			if (_drawFirstInCenter) {				d = DisplayObject(contents.getItem(0));				d.x = -(d.width >> 1);				d.y = -(d.height >> 1);								$addChild(d);					DisplayUtils.fixRegistrationPoint(d);			}						for (var i:uint = _drawFirstInCenter ? 1 : 0; i < contents.length; ++i) {				var x:Number = Math.cos(theta) * (theta / TWO_PI) * _xStretch;				var y:Number = Math.sin(theta) * (theta / TWO_PI) * _yStretch;								d = DisplayObject(contents.getItem(i));				d.x = x - (d.width >> 1);				d.y = y - (d.height >> 1);				if (_jitterer != null)					_jitterer(d);				$addChildAt(d, 0);				DisplayUtils.fixRegistrationPoint(d);												// Quick approximation of ellipse "arc" length -- accurate enough for this.				theta += (TWO_PI * _arcLength) / calculateCircumference(theta);			}						// Draw transparency.			with (graphics) {				clear();				beginFill(0x000000, 0.0);				drawRect(0, 0, width, height);				endFill();			}						if (stage)				DisplayUtils.fixRegistrationPoint(this);		}		private function semimajorAxis(theta:Number):Number {		    return _xStretch * (theta / TWO_PI + 1);		}				private function semiminorAxis(theta:Number):Number {			return _yStretch * (theta / TWO_PI + 1);		}						private function calculateCircumference(theta:Number):Number {			var a:Number = semimajorAxis(theta);			var b:Number = semiminorAxis(theta);			var a3:Number = 3 * a;			var b3:Number = 3 * b;			return Math.PI * (a3 + b3 - Math.sqrt((a3 + b) * (a + b3)));		}						/**		 * Whether or not to draw the first display object in the absolute		 * center of the spiral. Defaults to true.		 */		public function get drawFirstInCenter():Boolean {			return _drawFirstInCenter;		}		public function set drawFirstInCenter(value:Boolean):void {			_drawFirstInCenter = value;			initialize();			}								/**		 * The angle, in radians, at which to draw the first display object. If		 * drawFirstInCenter, this is the angle at which to draw the second		 * display object, since the first is in the center. Default is Ï€.		 */		public function get startingAngle():Number {			return _startingAngle;		}		public function set startingAngle(value:Number):void {			_startingAngle = value;			initialize();		}								/**		 * A function to provide variance on each added display object.		 * Default is null, which means no jitter is applied.		 */		public function get jitterer():Function {			return _jitterer;		}		public function set jitterer(value:Function):void {			_jitterer = value;			initialize();		}	}}