package net.petosky.display {	import net.petosky.util.DisplayUtils;		import net.petosky.util.FunctionUtils;			import net.petosky.util.ArrayUtils;			import caurina.transitions.Tweener;			import flash.display.DisplayObject;			import flash.events.Event;		import flash.events.MouseEvent;		import flash.display.Sprite;		/**	 * A SliderView displays components in a horizontal or vertical list.	 * Only navigation between discrete elements is allowed -- one cannot be	 * "between" elements.	 * 	 * Displayable slots are determined by a list of tween-to points. These	 * points are objects consisting of tweenable properties. Most importantly,	 * x and y can be specified in these points, but other DisplayObject	 * properties like scale and rotation can also be specified.	 * 	 * @author cpetosky	 */	public class SliderView extends BaseListView {		public static var LOW_BUFFER:String = "lowBuffer";				private static var DEFAULT_TIME:Number = 0.5;				private var _mask:Sprite;		private var _height:uint;		private var _width:uint;				private var _position:int = 0;				private var _tweenPoints:Array = new Array();				private var _defaults:Object;				private var _moving:Boolean = false;		private var _goalPosition:int;				private var _minBuffer:int = -1;				/**		 * Construct an empty SliderView.		 * 		 * @param height height of the slider view, in pixels		 * @param width width of the slider view, in pixels		 * @param args tween-to points		 */		public function SliderView(width:uint, height:uint, ...args) {			_height = height;			_width = width;						_mask = new Sprite();			with (_mask.graphics) {				beginFill(0);				drawRect(0, 0, _width, _height);				endFill();			}			$addChild(_mask);			mask = _mask;						for each (var o:Object in args)				addTweenPoint(o);							addEventListener(Event.ADDED_TO_STAGE, stageListener, false, 0, true);		}				private function stageListener(event:Event):void {			initialize();		}				private function addToDisplay(d:DisplayObject, pos:int):void {			var tweenPoint:Object = _tweenPoints[pos];			if (tweenPoint.scaleX)				d.scaleX = tweenPoint.scaleX;			if (tweenPoint.scaleY)				d.scaleY = tweenPoint.scaleY;						d.x = tweenPoint.x - d.width / 2;			d.y = tweenPoint.y - d.height / 2;						$addChild(d);			DisplayUtils.fixRegistrationPoint(d);					//if (stage)				//initialize();		}				/**		 * Adds a tween point to the end of the tween point list.		 * 		 * A tween point is an object full of tweenable properties for a 		 * DisplayObject. Usually, the most important properties are x and y,		 * but any other numeric DisplayObject property can also be tweened.		 */		public function addTweenPoint(o:Object):void {			o.x *= _width;			o.y *= _height;			_tweenPoints.push(o);		}						/**		 * True if the position is currently moving.		 */				public function get moving():Boolean {			return _moving;		}		/**		 * The index of the object currently in the prominent position.		 */		public function get position():int {			return _position;		}		public function set position(value:int):void {			deselectCurrent();			_goalPosition = value;			move();		}				/**		 * The smallest amount of objects ahead of the position allowed before		 * an event is thrown.		 * 		 * When position > length - minBuffer, a LOW_BUFFER event is broadcast.		 * In situations where the sliderview represents an infinite or 		 * paginated list, this allows the controlling class to insert more 		 * data.		 */		public function get minBuffer():int {			return _minBuffer;		}		public function set minBuffer(value:int):void {			_minBuffer = value;		}				private function move():void {			var down:Boolean = (_goalPosition - (position - internalPosition)) < internalPosition;			if (_moving)				_position += (down ? -1 : 1);			if (_goalPosition == _position) {				if (contents.length - _position - 1 <= _minBuffer)					dispatchEvent(new Event(LOW_BUFFER));				_moving = false;				selectCurrent();				return;			}			var transition:String;			if (_moving)				if (Math.abs(_goalPosition - _position) == 1)					transition = "easeOutQuad";				else					transition = "linear";			else				if (Math.abs(_goalPosition - _position) == 1)					transition = "easeInOutQuad";				else					transition = "easeInQuad";						_moving = true;						var maxTime:Number = 0;									for (var i:uint = 0; i < numChildren; ++i) {				var d:DisplayObject = getChildAt(i);				if (d === _mask)					continue;				var slot:int = getTweenPosition(d);				if ((down ? (slot < _tweenPoints.length - 1) : (slot > 0))) {					var tween:Object = ArrayUtils.mergeObjects(_defaults, _tweenPoints[slot + (down ? 1 : -1)]);					if (tween.time == undefined)						tween.time = DEFAULT_TIME;											tween.transition = transition;										if (tween.time > maxTime)						maxTime = tween.time;										var osX:Number, osY:Number;										if (tween.scaleX) {						osX = d.scaleX;						d.scaleX = tween.scaleX;					}					if (tween.scaleY) {						osY = d.scaleY;						d.scaleY = tween.scaleY;					}											tween.x -= d.width / 2;					tween.y -= d.height / 2;										if (tween.scaleX)						d.scaleX = osX;					if (tween.scaleY)						d.scaleY = osY;											Tweener.addTween(d, tween);				} else {					$removeChild(d);					--i;				}			}			// Add new element to screen			var n:int = internalPosition + (down ? -1 : (_tweenPoints.length));			if (n >= 0 && n < contents.length) {				d = DisplayObject(contents.getItem(n));				addToDisplay(d, down ? 0 : _tweenPoints.length - 1);			}						FunctionUtils.invokeLater(maxTime * 1000, this, move);		}				private function get internalPosition():int {			// Center tween points if there's an odd number of 'em			if (_tweenPoints.length % 2 == 1)				return _position - Math.floor(_tweenPoints.length / 2);			else				return _position;		}				private function clickListener(event:MouseEvent):void {			var d:DisplayObject = event.currentTarget as DisplayObject;						var p:int = getTweenPosition(d);			if (p >= 0)				position = internalPosition + p;		}				private function getTweenPosition(d:DisplayObject):int {			var x:Number = d.x + d.width / 2;			var y:Number = d.y + d.height / 2;			for (var i:uint = 0; i < _tweenPoints.length; ++i)				if (Math.abs(x - _tweenPoints[i].x) < 0.1 && Math.abs(y - _tweenPoints[i].y) < 0.1)					return i;			return -1;		}				override protected function itemAdded(d:DisplayObject):void {			d.addEventListener(MouseEvent.CLICK, clickListener);		}				override protected function itemRemoved(d:DisplayObject):void {			d.removeEventListener(MouseEvent.CLICK, clickListener);		}		override protected function initialize():void {			clearChildren(1);			for (var i:int = 0; i < _tweenPoints.length; ++i) {				var p:int = internalPosition + i;				if (p < 0)					continue;				if (p >= contents.length)					break;								addToDisplay(DisplayObject(contents.getItem(p)), i);			}			selectCurrent();		}				public function next():Boolean {			if (_goalPosition != _position)				return false;			else {				++position;				return true;			}		}				public function previous():Boolean {			if (_goalPosition != _position)				return false;			else {				--position;				return true;			}		}				private function deselectCurrent():void {			if (_position < contents.length) {				var current:ISliderViewElement = contents.getItem(_position) as ISliderViewElement;				if (current)					current.onDeselect();			}		}		private function selectCurrent():void {			if (_position < contents.length) {				var current:ISliderViewElement = contents.getItem(_position) as ISliderViewElement;				if (current)					current.onSelect();			}		}	}}