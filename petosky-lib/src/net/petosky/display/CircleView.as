package net.petosky.display {		import net.petosky.util.DisplayUtils;		import net.petosky.util.MatrixUtils;			import caurina.transitions.Tweener;			import net.petosky.util.Matrix;			import flash.display.DisplayObject;			import flash.events.Event;		import flash.events.MouseEvent;				/**	 * A CircleView displays a set of DisplayObjects spaced around a circle	 * in 3-space. The circle has its center at the origin and lies on the	 * x-z plane. The user can use his mouse to rotate the circle about the	 * y axis.	 * 	 * A rotation matrix can be provided so the circle has some other	 * orientation. In this case, rotation occurs about an axis perpendicular	 * to the circle's plane.	 * 	 * @author cpetosky	 */	public class CircleView extends BaseListView {		public static var SPIN_START:String = "spinStart";		public static var SPIN_STOP:String = "spinStop";				private static var TWO_PI:Number = Math.PI * 2; 		private var _r:uint;		private var _matrix:Matrix;				private var _middleground:DisplayObject;		private var _lastRotation:Number = 0;		private var _position:Number = 0;		private var _displayLimit:uint = 0;				private var _minScale:Number;		private var _maxScale:Number;		private var _scale:Boolean;		private var _rotationRate:Number = TWO_PI / 20;		private var _minX:int = int.MAX_VALUE;		private var _maxX:int = int.MIN_VALUE;		private var _minY:int = int.MAX_VALUE;		private var _maxY:int = int.MIN_VALUE;				private var _xOffset:int = 0;		private var _yOffset:int = 0;		private var _scaleFactor:Number = 1;		/**		 * Construct an empty CircleNav.		 * 		 * @param radius radius of the circle, in pixels.		 * @param rotationMatrix Matrix used to rotate the circle.		 */		public function CircleView(radius:uint, scale:Boolean = true, minScale:Number = 0, maxScale:Number = 1, rotationMatrix:Matrix = null) {			_r = radius;			_matrix = rotationMatrix || Matrix.identity(3);			_scale = scale;			_minScale = minScale;			_maxScale = maxScale;						addEventListener(MouseEvent.ROLL_OVER, mouseOverListener, false, 0, true);			addEventListener(MouseEvent.ROLL_OUT, mouseOutListener, false, 0, true);			addEventListener(Event.ADDED_TO_STAGE, stageListener, false, 0, true);		}								/**		 * To scale or not to scale. With scaling enabled, the size of each		 * element changes based upon its computed position along the z-axis.		 * With scaling turned off, all elements appear at their normal size		 * regardless of their z position.		 * 		 * When scaling is enabled, the range of z-values is linearly modified		 * to lie between minScale and maxScale -- the smallest possible		 * z-value will always map to exactly minScale, and the largest		 * possible z-value will always map to exactly maxScale.		 * 		 * Setting minScale and maxScale to the same number effectively turns		 * scaling off and instead applies a constant scale to all components		 * of this CircleView.		 * 		 * Default is on.		 * 		 * @see minScale		 * @see maxScale		 */		public function get scale():Boolean {			return _scale;		}		public function set scale(value:Boolean):void {			_scale = value;			for (var i:uint = 0; i < contents.length; ++i) {				var d:DisplayObject = DisplayObject(contents.getItem(i));				d.scaleX = d.scaleY = 1;			}			initialize();		}								/**		 * The minimum value any component in this circle view can be scaled		 * to.		 * 		 * Default is 0.		 * 		 * @see scale		 */		public function get minScale():Number {			return _minScale;		}		public function set minScale(value:Number):void {			_minScale = value;			initialize();		}								/**		 * The maximum value any component in this circle view can be scaled		 * to.		 * 		 * Default is 1.		 * 		 * @see scale		 */		public function get maxScale():Number {			return _maxScale;		}		public function set maxScale(value:Number):void {			_maxScale = value;			initialize();		}								/**		 * The maximum angle the CircleView can rotate in a single frame, in		 * radians.		 * 		 * Defaults to a twentieth of pi -- this provides for a full rotation		 * in 40 frames, at maximum rotation rate.		 */		public function get rotationRate():Number {			return _rotationRate;		}		public function set rotationRate(value:Number):void {			_rotationRate = value;		}								/**		 * The list item which should appear at canonical position (0, 1).		 * Fractional positions are allowed -- for example, position 0.5 would		 * place the point on the circle midway between objects 0 and 1 at		 * canonical position (0, 1).		 * 		 * The position starts at 0.		 */		public function get position():Number {			return _position;		}		public function set position(value:Number):void {			_position = value;			initialize();		}								/**		 * The displayLimit is the maximum number of objects that can appear		 * in the circle at one time. If more than this number of items exist		 * in the list, only the ones closest to the current position are		 * shown.		 * 		 * You can set the displayLimit to 0 to disable limiting.		 * 		 * Default is no limit.		 */		public function get displayLimit():uint {			return _displayLimit;		}		public function set displayLimit(value:uint):void {			_displayLimit = value;			initialize();		}						/**		 * The middleground is a DisplayObject that appears in the center		 * of the circle. Objects on the circle will fly in front and behind		 * the middleground.		 * 		 * The middleground's position is set by the caller -- no attempt is		 * made to center it. The middleground is assumed to have a z value of		 * 0. The middleground is never scaled, regardless of the scaling		 * settings. The middleground is not affected by x and y offsets or		 * the global scale factor.		 * 		 * By default, there is no middleground.		 * 		 * @see xOffset		 * @see yOffset		 * @see scaleFactor		 */		public function get middleground():DisplayObject {			return _middleground;		}		public function set middleground(value:DisplayObject):void {			_middleground = value;			initialize();		}						/**		 * The xOffset is applied equally to all objects in the circle,		 * regardless of their position. This is a convenience property for		 * tween support -- one can tween the xOffset to move the circle		 * horizontally without moving the middleground.		 * 		 * This property is applied to the real coordinates of the circle		 * objects, not to their canonical positions.		 * 		 * @see yOffset		 */				public function get xOffset():int {			return _xOffset;		}		public function set xOffset(value:int):void {			_xOffset = value;			initialize();		}								/**		 * The yOffset is applied equally to all objects in the circle,		 * regardless of their position. This is a convenience property for		 * tween support -- one can tween the yOffset to move the circle		 * vertically without moving the middleground.		 * 		 * This property is applied to the real coordinates of the circle		 * objects, not to their canonical positions.		 * 		 * @see xOffset		 */		public function get yOffset():int {			return _yOffset;		}		public function set yOffset(value:int):void {			_yOffset = value;			initialize();		}								/**		 * The scaleFactor is applied equally to all objects in the circle,		 * regardless of their position. This is a convenience property for		 * tween support -- one can tween the scale factor to simulate zooming		 * the circle without zooming the middleground.		 * 		 * @see minScale		 * @see maxScale		 */		public function get scaleFactor():Number {			return _scaleFactor;		}		public function set scaleFactor(value:Number):void {			_scaleFactor = value;			initialize();		}						public function get radius():uint {			return _r;			}		public function set radius(value:uint):void {			_r = value;						// Reset all calculations			_minX = int.MAX_VALUE;			_maxX = int.MIN_VALUE;			_minY = int.MAX_VALUE;			_maxY = int.MIN_VALUE;			initialize();			initialize();		}				private function stageListener(event:Event):void {			// A lot of render parameters are calculated and adjusted on the			// fly, so we render twice the first time -- first to do the			// initial calculations, and second to render properly based on			// those calculations.			initialize();			initialize();		}								private function mouseOverListener(event:MouseEvent):void {			Tweener.removeTweens(this);			Tweener.addTween(this, {				position: _position + 2 * motion,				time: 0.5,				transition: "easeInCubic",				onUpdate: initialize,				onComplete: startEnterFrame			});						dispatchEvent(new Event(SPIN_START));		}								private function mouseOutListener(event:MouseEvent):void {			Tweener.removeTweens(this);			removeEventListener(Event.ENTER_FRAME, enterFrameListener);			Tweener.addTween(this, {				position: _position + 2 * _lastRotation,				time: 0.5,				transition: "easeOutCubic",				onUpdate: initialize,				onComplete: dispatchSpinStop			});		}								private function startEnterFrame():void {			addEventListener(Event.ENTER_FRAME, enterFrameListener, false, 0, true);		}								private function dispatchSpinStop():void {			dispatchEvent(new Event(SPIN_STOP));		}								private function enterFrameListener(event:Event):void {			handleMotion();			initialize();		}								/**		 * Calculate this frame's motion, using a quintic function relative to		 * the center of the circle's x axis.		 * 		 * @return motion		 */		private function get motion():Number {			_lastRotation = angleToPosition(Math.pow(-((mouseX / (width / 2)) - 1), 5) * _rotationRate);			return _lastRotation;		}								/**		 * Rotate according to the motion this frame.		 */		private function handleMotion():void {			_position += motion;			_position = (_position + contents.length) % contents.length;		}						/**		 * The number of items visible in the circle.		 */		private function get itemsToDisplay():uint {			return _displayLimit || contents.length;		}								/**		 * The angular distance, in radians, between every two consecutive		 * objects in the circle.		 */		private function get angleDiff():Number {			return TWO_PI / itemsToDisplay;		}								private function angleToPosition(theta:Number):Number {			return theta / angleDiff;		}								/**		 * The angle, in radians, at which element i exists.		 */		private function getAngle(i:uint):Number {			if (_displayLimit > 0) {				var p:Number = _position % 1;				var k:Number;								if (p < 0.5)					k = 0.5 - p;				else					k = 1.5 - p;									return (i + k) * angleDiff + Math.PI;			} else {				return ((i - (_position % 1)) * angleDiff);			}		}								/**		 * Where to start rendering.		 */		private function get initialItem():uint {			if (_displayLimit > 0) {				return Math.round(contents.length + _position - Math.floor(_displayLimit / 2)) % contents.length;			} else {				return (contents.length + Math.floor(_position)) % contents.length;			}					}								/**		 * Render all currently visible objects onto the screen.		 */
		override protected function initialize():void {			clearChildren();							const addedDepths:Array = [];						var itemPosition:uint = initialItem;									for (var i:uint = 0; i < itemsToDisplay; ++i) {				var angle:Number = getAngle(i);								var vector:Matrix = getCanonicalLocation(angle);				vector = _matrix.times(vector);								var d:DisplayObject = DisplayObject(contents.getItem(itemPosition));				// Scale object				if (_scale)					d.scaleX = d.scaleY = modifyZ(vector[2][0]);				// Center object at new location				d.x = Math.floor(vector[0][0] - (d.width / 2));				d.y = Math.floor(vector[1][0] - (d.height / 2));				updateMinMax(d.x, d.y, Math.floor(d.x + d.width), Math.floor(d.y + d.height));				applyOffsets(d);								// Calculate depth and insert at the right spot				var depth:uint;				for (depth = 0; depth < numChildren && addedDepths[depth] < vector[2][0]; ++depth);				$addChildAt(d, depth);				DisplayUtils.fixRegistrationPoint(d);								addedDepths.splice(depth, 0, vector[2][0]);								itemPosition = (itemPosition + 1) % contents.length;			}						drawMiddleground(addedDepths);			drawHitArea();		}								/**		 * Returns the vector corresponding to the angle (on the x-z plane)		 * provided.		 * 		 * @param angle angle on the x-z plane.		 * @returns column vector		 */		private function getCanonicalLocation(angle:Number):Matrix {			return MatrixUtils.createColumnVector(				-Math.sin(angle) * _r,				0,				Math.cos(angle) * _r			);					}								/**		 * Applies various system-wide offsets to the provided DisplayObject.		 * 		 * Specifically, this function:		 * 		 * 1. Shifts the display object to be relative to 0, 0 using the		 *    minimum x and y values for the system.		 * 2. Applies global xOffset and yOffset to the display object.		 * 3. Modifies scale by the scaleFactor.		 */		private function applyOffsets(d:DisplayObject):void {			d.x += _xOffset - _minX;			d.y += _yOffset - _minY;			d.scaleX *= _scaleFactor;			d.scaleY *= _scaleFactor;					}								/**		 * Use provided x's and y's to update the circle's overall		 * minimum and maximum x and y values.		 */		private function updateMinMax(x1:int, y1:int, x2:int, y2:int):void {			if (x1 < _minX)				_minX = x1;			if (x2 > _maxX)				_maxX = x2;							if (y1 < _minY)				_minY = y1;			if (y2 > _maxY)				_maxY = y2;					}						/**		 * Linearly map input to [_minScale, _maxScale].		 * 		 * @return mapped value 		 */		private function modifyZ(oldZ:Number):Number {			if (_minScale == _maxScale) {				return _minScale;			} else {				var i:Number = ((oldZ / _r) + 1) / 2;				return (i * _maxScale) + (1 - i) * _minScale;			}		}								/**		 * Draw middleground, with middleground.z = 0.		 */		private function drawMiddleground(depths:Array):void {			if (_middleground) {				if (_middleground.parent == this)					$removeChild(_middleground);								for (var depth:uint = 0; depth < numChildren && depths[depth] < 0; ++depth);								$addChildAt(_middleground, depth);			}					}				/**		 * Draw a transparent vector to act as the hit area for the circle.		 */		private function drawHitArea():void {			with (graphics) {				clear();				beginFill(0, 0);				drawRect(0, 0, _maxX - _minX, _maxY - _minY);				endFill();			}					}	}}