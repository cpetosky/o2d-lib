package net.petosky.display {	import net.petosky.util.NumberUtils;			import flash.events.Event;		import flash.display.Sprite;			/**	 * A ProgressBar shows the progress of anything, usually load operations.	 * Because ProgressBar extends Sprite, one can apply rotations and a mask	 * to the ProgressBar so that it appears to be any shape and filling in	 * any direction.	 * 	 * @author cpetosky	 */	public class ProgressBar extends Sprite {		private var _barWidth:int;		private var _barHeight:int;		private var _mainColor:uint;		private var _mainAlpha:Number;		private var _bgColor:uint;		private var _bgAlpha:Number;				private var _continuous:Boolean;		private var _progress:Number = 0;				private var _bg:Sprite = new Sprite();		private var _fg:Sprite = new Sprite();				/**		 * Create a new ProgressBar.		 * 		 * @param barWidth   The width of the bar, in pixels.		 * @param barHeight  The height of the bar, in pixels.		 * @param continuous Whether the bar is continuous or not.		 * @param mainColor  The color of the filled portion of the bar, in		 *                   0x###### format.		 * @param mainAlpha  The translucency of the filled portion of the bar,		 *                   where 0 is transparent and 1 is opaque.		 * @param bgColor    The color of the empty portion of the bar, in		 *                   0x###### format.		 * @param bgAlpha    The translucency of the empty portion of the bar,		 *                   where 0 is transparent and 1 is opaque.		 */		public function ProgressBar(			barWidth:int,			barHeight:int,			continuous:Boolean = false,			mainColor:uint = 0,			mainAlpha:Number = 1,			bgColor:uint = 0xFFFFFF,			bgAlpha:Number = 0)		{			_barWidth = barWidth;			_barHeight = barHeight;			_mainColor = mainColor;			_mainAlpha = mainAlpha;			_bgColor = bgColor;			_bgAlpha = bgAlpha;									addChild(_bg);			addChild(_fg);						var m:Sprite = new Sprite();			with (m.graphics) {				beginFill(0, 0);				drawRect(0, 0, _barWidth, _barHeight);				endFill();			}			addChild(m);						mask = m;									addEventListener(Event.ADDED_TO_STAGE, stageListener, false, 0, true);						this.continuous = continuous;		}				private function stageListener(event:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, stageListener);						if (_bgAlpha > 0) {				with (_bg.graphics) {					beginFill(_bgColor, _bgAlpha);						drawRect(0, 0, _barWidth, _barHeight);					endFill();				}			}		}				private function renderProgress(event:Event = null):void {			if (_mainAlpha > 0) {				if (_continuous) {					_fg.x = (_fg.x + 2);					if (_fg.x > _barWidth)						_fg.x = -_fg.width + 1;				} else {					with (_fg.graphics) {						clear();						beginFill(_mainColor, _mainAlpha);						drawRect(0, 0, _barWidth * _progress, _barHeight);						endFill();					}				}			}		}				/**		 * The percentage of the bar that's filled, where 0 is completely empty		 * and 1 is completely filled.		 */		public function get progress():Number {			return _progress;		}		public function set progress(value:Number):void {			_progress = NumberUtils.clamp(0, value, 1);			renderProgress();		}				/**		 * Whether the progress bar obeys its progress property.		 * If this property is false (the default), the progress bar fills		 * based on its progress percentage. If this property is true, the		 * progress bar constantly shows progress. This is useful in cases		 * where you can't know the total amount of loading that needs to		 * occur.		 */		public function get continuous():Boolean {			return _continuous;		}		public function set continuous(value:Boolean):void {			if (value == _continuous)				return;							_continuous = value;			if (_continuous) {				with (_fg.graphics) {					clear();					beginFill(_mainColor, _mainAlpha);					drawRect(0, 0, _barWidth * 0.25, _barHeight);					endFill();				}				_fg.x = -_fg.width + 1;				addEventListener(Event.ENTER_FRAME, renderProgress, false, 0, true); 			} else {				_fg.x = 0;				renderProgress();				removeEventListener(Event.ENTER_FRAME, renderProgress);			}		}	}}