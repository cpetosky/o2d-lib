package net.petosky.display {	import flash.geom.Point;			import net.petosky.collections.TypedQueue;		import net.petosky.collections.IQueue;		import net.petosky.collections.PriorityQueue;		import net.petosky.util.MathUtils;			import flash.events.Event;		import flash.events.MouseEvent;		import flash.display.DisplayObject;			/**	 * @author cpetosky	 */	public class PileView extends SpiralView {		private var _viewDistance:Number;		private var _pushForce:Number;				private var _springDistance:Number;				private var _width:uint;		private var _height:uint;		private var _nodes:Array;						public function PileView(			arcLength:Number,			xStretch:Number = 1,			yStretch:Number = 1,			viewDistance:Number = 75,			pushForce:Number = 2,			springDistance:Number = 30		) {			super(arcLength, xStretch, yStretch);						_width = width;			_height = height;			_viewDistance = viewDistance;			_pushForce = pushForce;			_springDistance = springDistance;			addEventListener(Event.ADDED_TO_STAGE, stageListener, false, 0, true);		}				private function stageListener(event:Event):void {			addEventListener(Event.ENTER_FRAME, frameListener, false, 0, true);		}				override protected function initialize():void {			super.initialize();			_width = width;			_height = height;						if (_nodes)				for each (var node:Node in _nodes)					node.reset();						_nodes = new Array();						for each (var d:DisplayObject in contents.toArray())				_nodes.push(new Node(d, 0, _springDistance));		}				private function frameListener(event:Event):void {			var q:IQueue = new TypedQueue(Node, new PriorityQueue("distance"));			for each (var node:Node in _nodes) {				node.distance = MathUtils.distance(node.d.x + (node.d.width >> 1), node.d.y + (node.d.height >> 1), mouseX, mouseY);				q.enqueue(node);			}						var scaleFactor:Number = 1;			const scaleDrop:Number = 1 / q.length / 2;			const firstBonus:Number = 0.15;						while (!q.empty) {				var n:Node = q.dequeue() as Node;								// Leave current selection alone				if (getChildIndex(n.d) != numChildren - 1) {					var p:Point;					var move:Number;					var distance:Number;										if (n.distance < _viewDistance - _pushForce * 0.55) {						p = new Point(n.d.x + (n.d.width / 2) - mouseX, n.d.y + (n.d.height / 2) - mouseY);						move = ((_viewDistance - n.distance) / _viewDistance) * _pushForce;						p.normalize(1); // Get unit vector						n.shift(move * p.x, move * p.y);					} else if (n.distance > _viewDistance + _pushForce * 0.55) {						p = new Point(n.x - n.d.x, n.y - n.d.y);						distance = MathUtils.distance(n.d.x, n.d.y, n.x, n.y);						move = (distance / _springDistance) * _pushForce;						p.normalize(1); // Get unit vector						n.shift(move * p.x, move * p.y);					}				} 								// Extra scale current selection				if (getChildIndex(n.d) == numChildren - 1)					n.scale(scaleFactor + firstBonus);				else					n.scale(scaleFactor);									scaleFactor -= scaleDrop;			}		}				override protected function itemAdded(d:DisplayObject):void {			d.addEventListener(MouseEvent.MOUSE_OVER, mouseOverListener, false, 0, true);		}				private function mouseOverListener(event:MouseEvent):void {			var d:DisplayObject = event.currentTarget as DisplayObject;			setChildIndex(d, numChildren - 1);		}	}}import flash.display.DisplayObject;import net.petosky.util.NumberUtils;class Node {	public var d:DisplayObject;	public var distance:Number;	private var _originalX:Number;	private var _originalY:Number;	private var _originalScale:Number;	private var _maxSpring:Number;		public function Node(d:DisplayObject, distance:Number, maxSpring:Number) {		this.d = d;		this.distance = distance;		_originalX = d.x;		_originalY = d.y;		_originalScale = d.scaleX;		_maxSpring = maxSpring;	}	public function toString():String {		return "[" + d.name + "," + distance + "]";	}		public function reset():void {		d.x = _originalX;		d.y = _originalY;		d.scaleX = d.scaleY = _originalScale;	}	public function shift(x:int, y:int):void {		d.x = NumberUtils.clamp(_originalX - _maxSpring, d.x + x, _originalX + _maxSpring);		d.y = NumberUtils.clamp(_originalY - _maxSpring, d.y + y, _originalY + _maxSpring);	}		public function get x():int {		return _originalX;	}		public function get y():int {		return _originalY;	}		public function scale(factor:Number):void {		var oldWidth:Number = d.width;		var oldHeight:Number = d.height;		d.scaleX = d.scaleY = _originalScale * factor;		d.x -= (d.width - oldWidth) / 2;		d.y -= (d.height - oldHeight) / 2;	}}