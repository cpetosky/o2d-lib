package net.petosky.display {	import net.petosky.collections.IListIterator;		import net.petosky.collections.ArrayList;		import net.petosky.collections.TypedList;			import flash.display.DisplayObject;			import net.petosky.collections.IList;			import flash.display.Sprite;			/**	 * A BaseListView provides the underlying structure for display managers	 * that show a list of DisplayObjects. It can be extended to provide	 * meaningful functionality.	 * 	 * Do not directly instantiate this class -- it doesn't do anything by	 * itself.	 * 	 * @author cpetosky	 */	public class BaseListView extends Sprite implements IList {		private var _contents:IList;				/**		 * Initializes the internal contents data structure. This function		 * should not be called directly.		 */		public function BaseListView() {			_contents = new TypedList(DisplayObject, new ArrayList());		}								/**		 * The backing data structure for this view. Only DisplayObjects can		 * be inserted into this list -- an error will be thrown for any other		 * data type.		 */		protected function get contents():IList {			return _contents;		}						/**		 * Called whenever the contents list is altered. This is useful if		 * changing one element in the view requires that the entire view		 * be redrawn. It can also be used as the primary render function		 * for views that must be redrawn every frame.		 * 		 * This function does nothing by default -- it must be overridden to		 * provide functionality.		 */		protected function initialize():void { }								/**		 * Called whenever a new DisplayObject is added to the view.		 * 		 * This function does nothing by default -- it must be overridden to		 * provide functionality.		 */				protected function itemAdded(d:DisplayObject):void { }								/**		 * Called just before a DisplayObject is removed from the view.		 * 		 * This function does nothing by default -- it must be overridden to		 * provide functionality.		 */		protected function itemRemoved(d:DisplayObject):void { }		/**		 * Removes all children with index greater than numToKeep. By default,		 * numToKeep is 0, which causes all children to be removed.		 * 		 * @param numToKeep the number of display objects to ignore		 */		protected function clearChildren(numToKeep:int = 0):void {			while (numChildren > numToKeep)				$removeChildAt(numToKeep);		}		/**		 * Adds a child to this container. This uses the container's custom 		 * rendering method.		 */		override public function addChild(d:DisplayObject):DisplayObject {			add(d);			return d;		}								/**		 * Adds a child to this container at the specified index. This uses the		 * container's custom rendering method.		 */		override public function addChildAt(d:DisplayObject, index:int):DisplayObject {			insert(index, d);			return d;		}			/**		 * Removes a child from this container. This uses the container's		 * custom rendering method.		 */		override public function removeChild(d:DisplayObject):DisplayObject {			remove(d);			return d;		}									/**		 * Removes the child at the specified index from this container. This		 * uses the container's custom rendering method.		 */		override public function removeChildAt(index:int):DisplayObject {			var d:DisplayObject = DisplayObject(getItem(index));			remove(d);			return d;		}		/**		 * Provides access to the default addChild implementation.		 */		final protected function $addChild(d:DisplayObject):DisplayObject {			return super.addChild(d);		}								/**		 * Provides access to the default addChildAt implementation.		 */		final protected function $addChildAt(d:DisplayObject, index:int):DisplayObject {			return super.addChildAt(d, index);		}								/**		 * Provides access to the default removeChild implementation.		 */		final protected function $removeChild(d:DisplayObject):DisplayObject {			return super.removeChild(d);		}								/**		 * Provides access to the default removeChildAt implementation.		 */		final protected function $removeChildAt(index:int):DisplayObject {			return super.removeChildAt(index);		}						// ********************************************************************		// IList members		// ********************************************************************		/**		 * Removes all content from this container.		 * 		 * This function triggers <code>itemRemoved</code> on all elements and		 * <code>initialize</code>.		 */		public function clear():void {			for (var i:uint = 0; i < _contents.length; ++i)				itemRemoved(DisplayObject(_contents.getItem(i)));			_contents.clear();			initialize();		}								/**		 * Replaces the item at <code>index</code> with <code>value</code>.		 * 		 * This triggers <code>itemAdded</code> on <code>value</code>,		 * <code>itemRemoved</code> on the existing element at that position,		 * and <code>initialize</code>.		 * 		 * This function runs in constant time.		 * 		 * @param index the position to set the value		 * @param value the display object that gets set in the contents		 * 		 * @return the replaced display object		 * 		 * @throws RangeError if index not in [0, contents.length)		 */		public function setItem(index:uint, value:Object):Object {			itemRemoved(DisplayObject(_contents.getItem(index)));			var o:* = _contents.setItem(index, value);						itemAdded(DisplayObject(value));			initialize();						return o;		}								/**		 * Returns the item at this index.		 * 		 * This function runs in constant time.		 * 		 * @param index the index to access		 * @return the item at this position		 * 		 * @throws RangeError if index is not in [0, contents.length)		 */		public function getItem(index:uint):Object {			return _contents.getItem(index);		}		/**		 * Inserts elements into the container. Elements at and after		 * <code>index</code> are moved to make room for the new elements.		 * 		 * This function triggers <code>itemAdded</code> on all new elements		 * and <code>initialize</code>.		 * 		 * @param index place to insert		 * @param args elements to insert		 * 		 * @return true if insertion was successful		 */		public function insert(index:uint, ...args):Boolean {			return insertArray(index, args);		}		/**		 * Inserts elements into the container. Elements at and after		 * <code>index</code> are moved to make room for the new elements.		 * 		 * This function triggers <code>itemAdded</code> on all new elements		 * and <code>initialize</code>.		 * 		 * @param index place to insert		 * @param a array of elements to insert		 * 		 * @return true if insertion was successful		 */		public function insertArray(index:uint, a:Array):Boolean {			var b:Boolean = _contents.insertArray(index, a);			for (var i:uint = 0; i < a.length; ++i)				itemAdded(a[i]);						initialize();						return b;		}		/**		 * Removes elements from the container. Elements after the removed		 * items are shifted back so no gaps appear in <code>contents</code>.		 * 		 * This function triggers <code>itemRemoved</code> on all removed		 * elements and <code>initialize</code>.		 * 		 * @param args elements to remove		 * @return true if <em>any</em> elements were removed		 */		public function remove(...args):Boolean {			return removeArray(args);		}				/**		 * Removes elements from the container. Elements after the removed		 * items are shifted back so no gaps appear in <code>contents</code>.		 * 		 * This function triggers <code>itemRemoved</code> on all removed		 * elements and <code>initialize</code>.		 * 		 * @param a elements to remove		 * @return true if <em>any</em> elements were removed		 */		public function removeArray(a:Array):Boolean {			for each (var d:DisplayObject in a)				itemRemoved(d);							var b:Boolean = _contents.removeArray(a);						initialize();						return b;		}		/**		 * Returns the first element where 		 * <code>element.propName == propValue</code>, or null if no such		 * element exists.		 * 		 * @param propName property to seach on		 * @param propValue value to search for		 * @return matching element or null 		 */		public function getFirstByProperty(propName:String, propValue:Object):Object {			return _contents.getFirstByProperty(propName, propValue);		}		/**		 * Returns the first index <code>i</code> where		 * <code>contents[i] == o</code>, or null if no such element exists.		 * 		 * @param o the element to search for		 */		public function indexOf(o:Object):int {			return _contents.indexOf(o);		}		/**		 * Adds elements to the end of this container.		 * 		 * This function triggers <code>itemAdded</code> on all new elements		 * and <code>initialize</code>.		 * 		 * @param args items to add		 * @return true if addition was successful		 */		public function add(...args):Boolean {			return addArray(args);		}				/**		 * Adds elements to the end of this container.		 * 		 * This function triggers <code>itemAdded</code> on all new elements		 * and <code>initialize</code>.		 * 		 * @param a items to add		 * @return true if addition was successful		 */		public function addArray(a:Array):Boolean {			var b:Boolean = _contents.addArray(a);						for (var i:uint = 0; i < a.length; ++i)				itemAdded(a[i]);			initialize();						return b;		}		/**		 * Returns the contents as an array. Changing this array does not		 * change the contents of the container. However, this is a shallow		 * copy -- if you change the properties of any display object in this		 * array, the changes <em>will</em> affect the rendered output.		 * 		 * @return shallow-copied array		 */		public function toArray():Array {			return _contents.toArray();		}		/**		 * The number of items in this container.		 */		public function get length():uint {			return _contents.length;		}		/**		 * True if <code>length == 0</code>.		 */		public function get empty():Boolean {			return _contents.empty;		}								public function getListIterator():IListIterator {			return _contents.getListIterator();		}
		
		
		
		public function sort(sortProperty:String = "", ascending:Boolean = true):void {			_contents.sort(sortProperty, ascending);		}	}}