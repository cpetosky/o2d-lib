package net.petosky.display {	import net.petosky.util.MathUtils;			import flash.geom.Point;		import flash.utils.Dictionary;		import flash.display.DisplayObject;		import flash.display.Sprite;		/**	 * A ThinContainer acts like a DisplayObjectContainer, but relays all	 * positioning to its children. If the ThinContainer is told to move, it	 * instead moves all of its children. If the ThinContainer is told to	 * scale, it instead scales all its children appropriately. This mechanic	 * enforces that the ThinContainer's coordinate space is always the same as	 * its parent, a relationship which is generally false for all other	 * containers.	 * 	 * The use of a ThinContainer allows one to apply filters in the FLA to a	 * scale-9 object, among other things.	 * 	 * @author cpetosky	 */	public class ThinContainer extends Sprite {		private var _width:Number;		private var _height:Number;		private var _scaleX:Number;		private var _scaleY:Number;		private var _xOffset:Number;		private var _yOffset:Number;		private var _rotation:Number;				private var _nominal:Dictionary = new Dictionary(false);		public function ThinContainer() {			_width = super.width;			_height = super.height;			_scaleX = super.scaleX;			_scaleY = super.scaleY;			_rotation = super.rotation;			_xOffset = _yOffset = 0;			for (var i:uint = 0; i < numChildren; ++i)				configureChild(getChildAt(i));		}								/**		 * Adds a child DisplayObject instance to this ThinContainer instance.		 * This silently adjusts the display object's position so that it fits		 * within the ThinContainer's coordinate space contract with the 		 * current parameters.		 * 		 * @param d DisplayObject to add		 * @return d		 */		override public function addChild(d:DisplayObject):DisplayObject {			return addChildAt(d, numChildren);		}						/**		 * Adds a child DisplayObject instance to this ThinContainer instance.		 * This silently adjusts the display object's position so that it fits		 * within the ThinContainer's coordinate space contract with the 		 * current parameters.		 * 		 * @param d DisplayObject to add		 * @param index position in which to add d		 * @return d		 */		override public function addChildAt(d:DisplayObject, index:int):DisplayObject {			configureChild(d);			super.addChildAt(d, index);						return d;		}								/**		 * Removes a child DisplayObject from this instance. This silently		 * reverts any adjustments to d performed by the ThinContainer. Note		 * that if you manually adjusted the display parameters of this		 * DisplayObject, your changes will be lost by this process.		 * 		 * @param d DisplayObject to remove		 * 		 * @throws ArgumentError if d is not a child of this container		 */		override public function removeChild(d:DisplayObject):DisplayObject {			super.removeChild(d);						var nominal:Object = _nominal[d];						d.x = nominal.x;			d.y = nominal.y;			d.scaleX = nominal.scaleX;			d.scaleY = nominal.scaleY;			d.rotation = nominal.rotation;						delete _nominal[d];						return d;		}								/**		 * Removes child at a certain position.		 * 		 * @see removeChild		 */		override public function removeChildAt(index:int):DisplayObject {			return removeChild(getChildAt(index));		}				private function configureChild(d:DisplayObject):void {			_nominal[d] = {				x: d.x,				y: d.y,				scaleX: d.scaleX,				scaleY: d.scaleY,				rotation: d.rotation			};						positionChild(d);					}		/**		 * Scales all children of this container horizontally.		 */		override public function get scaleX():Number {			return _scaleX;		}		override public function set scaleX(value:Number):void {			_scaleX = value;			positionChildren();		}								/**		 * Scales all children of this container vertically.		 */		override public function get scaleY():Number {			return _scaleY;		}		override public function set scaleY(value:Number):void {			_scaleY = value;			positionChildren();		}								/**		 * The width of the children of this container.		 * 		 * FIXME: This is calculated at construction time, and thus is only		 *        meaningful for embedded symbols.		 */		override public function get width():Number {			return _width * _scaleX;		}		override public function set width(value:Number):void {			scaleX = value / _width;		}								/**		 * The height of the children of this container.		 * 		 * FIXME: This is calculated at construction time, and thus is only		 *        meaningful for embedded symbols.		 */		override public function get height():Number {			return _height * _scaleY;		}		override public function set height(value:Number):void {			scaleY = value / _height;		}							/**		 * Horizontal offset applied to all children, relative to 0 in parent		 * coordinate space.		 */		override public function get x():Number {			return _xOffset;		}		override public function set x(value:Number):void {			_xOffset = value;			positionChildren();		}						/**		 * Vertical offset applied to all children, relative to 0 in parent		 * coordinate space.		 */		override public function get y():Number {			return _yOffset;		}		override public function set y(value:Number):void {			_yOffset = value;			positionChildren();		}						/**		 * Degrees to rotate all children, with respect to 0,0 in parent		 * coordinate space.		 */		override public function get rotation():Number {			return _rotation;		}		override public function set rotation(value:Number):void {			_rotation = value;			positionChildren();		}				private function positionChildren():void {			for (var i:uint = 0; i < numChildren; ++i) {				var d:DisplayObject = getChildAt(i);				positionChild(d);			}					}				private function positionChild(d:DisplayObject):void {			var baseX:Number = _nominal[d].x;			var baseY:Number = _nominal[d].y;			if (_rotation) {				// Create vector based on nominal x and y				var vector:Point = new Point(_nominal[d].x, _nominal[d].y);								// Store magnitude of that vector				var magnitude:Number = vector.length;								// Get unit vector				vector.normalize(1);								// Convert to angle (in radians)				var angle:Number = Math.acos(vector.x);				if (vector.y < 0)					angle = (Math.PI * 2) - angle;									// Add rotation				angle += MathUtils.degreesToRadians(_rotation);								// Convert new angle back to unit vector				vector.x = Math.cos(angle);				vector.y = Math.sin(angle);								// Lengthen to original magnitude				vector.normalize(magnitude);								// Get the new position				baseX = vector.x;				baseY = vector.y;			}			d.x = baseX * _scaleX + _xOffset;			d.y = baseY * _scaleY + _yOffset;			d.scaleX = _nominal[d].scaleX * _scaleX;			d.scaleY = _nominal[d].scaleY * _scaleY;			d.rotation = _nominal[d].rotation + _rotation;		}	}}