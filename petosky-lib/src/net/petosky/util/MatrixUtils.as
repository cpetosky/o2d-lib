package net.petosky.util {		/**	 * A set of static utilities for working with the Matrix class.	 * 	 * @author cpetosky	 * @see com.popularfront.data.Matrix	 */	public class MatrixUtils {		/**		 * Generates a 3x3 rotation matrix about the x axis.		 * 		 * @param angle angle, in radians, to rotate		 * @return 3x3 matrix		 * @see createYRotation		 * @see createZRotation		 * @see createComplexRotation		 */		public static function createXRotation(angle:Number):Matrix {			var m:Matrix = new Matrix(3, 3);			m[0][0] = 1;                m[0][1] = 0;                m[0][2] = 0;			m[1][0] = 0;                m[1][1] = Math.cos(angle);  m[1][2] = -Math.sin(angle);			m[2][0] = 0;                m[2][1] = Math.sin(angle);  m[2][2] = Math.cos(angle);						return m;		}								/**		 * Generates a 3x3 rotation matrix about the y axis.		 * 		 * @param angle angle, in radians, to rotate		 * @return 3x3 matrix		 * @see createXRotation		 * @see createZRotation		 * @see createComplexRotation		 */		public static function createYRotation(angle:Number):Matrix {			var m:Matrix = new Matrix(3, 3);			m[0][0] = Math.cos(angle);  m[0][1] = 0;                m[0][2] = Math.sin(angle);			m[1][0] = 0;                m[1][1] = 1;                m[1][2] = 0;			m[2][0] = -Math.sin(angle); m[2][1] = 0;                m[2][2] = Math.cos(angle);						return m;		}				/**		 * Generates a 3x3 rotation matrix about the z axis.		 * 		 * @param angle angle, in radians, to rotate		 * @return 3x3 matrix		 * @see createXRotation		 * @see createYRotation		 * @see createComplexRotation		 */		public static function createZRotation(angle:Number):Matrix {			var m:Matrix = new Matrix(3, 3);			m[0][0] = Math.cos(angle);  m[0][1] = -Math.sin(angle); m[0][2] = 0;			m[1][0] = Math.sin(angle);  m[1][1] = Math.cos(angle);  m[1][2] = 0;			m[2][0] = 0;                m[2][1] = 0;                m[2][2] = 1;						return m;		}				/**		 * Create a complex rotation matrix encapsulating many individual		 * rotations.		 * 		 * Arguments must come in the following pairs:		 * axis:String, angle:Number		 * 		 * where axis is one of "x", "y", or "z" and angle is measured in		 * radians.		 * 		 * This function applies the rotations sequentially, so the order of		 * argument pairs is important.		 * 		 * @return 3x3 rotation matrix		 */		public static function createComplexRotation(...args):Matrix {			if (i % 2 == 1)				throw new ArgumentError("[MatrixUtils.createComplexRotation] Arguments must be paired!");			var m:Matrix = Matrix.identity(3);							for (var i:uint = 0; i < args.length; i += 2) {				if (!(args[i + 1] is Number))					throw new ArgumentError("[MatrixUtils.createComplexRotation] Argument " + (i + 1) + " must be a number!");									var n:Matrix;				switch (args[i].toLowerCase()) {					case "x":						n = createXRotation(args[i + 1]);					break;					case "y":						n = createYRotation(args[i + 1]);					break;					case "z":						n = createZRotation(args[i + 1]);					break;					default:						throw new ArgumentError("[MatrixUtils.createComplexRotation] Argument " + i + " must be x, y, or z!");				}				m = m.times(n);			}						return m;		}								/**		 * Creates a column vector from the arguments provided. A column vector		 * is a matrix with only one column.		 * 		 * @return nx1 matrix		 */		public static function createColumnVector(...args):Matrix {			if (args.length == 0)				throw new ArgumentError("[GeomUtil.createColumnVector] Must supply at least one argument!");						if (args[0] is Array)				args = args[0];			var height:uint = args.length;			var m:Matrix = new Matrix(height, 1);						for (var i:uint = 0; i < height; ++i)				m[i][0] = args[i];						return m;		}	}}