package net.petosky.util {	import flash.geom.Point;		import flash.display.Sprite;		import flash.display.DisplayObjectContainer;		import flash.geom.Rectangle;		import flash.display.DisplayObject;	import flash.display.MovieClip;		/**	 * @author cpetosky	 * @author awelters	 */	final public class DisplayUtils {		/**		 * Gross hack -- do not use unless you really, really need to.		 * 		 * No, I'm serious. It's totally unreliable.		 * 		 * This function takes a display object and moves its "registration		 * point" to its top-left corner.... kinda. If the object is a 		 * display object container, it works pretty well -- it takes all the		 * children and moves them so that nothing extends into negative		 * coordinate space.		 * 		 * If the object is not a display object container (like a Bitmap), 		 * this function just shifts the x and y value of the object itself.		 * This means that repeated calls to this function will shuffle your		 * object across the screen. That said, bitmaps generally only have		 * things in negative space if you've applied filters to them, so this		 * usually isn't a huge issue.		 * 		 * If the display object has programmatically-drawn graphics (via the		 * object's graphics property), this function totally fails, as you		 * can't move that stuff. Not only will this function not do what it		 * claims, it will move any children of the display object without		 * moving the graphics drawn with code. This leaves you with a mangled,		 * hideous image.		 * 		 * Finally, this function adds the display object to a temporary parent		 * if it doesn't have one already. If you have event listeners on the		 * Event.ADDED, they will fire, probably breaking something.		 * 		 * @param d DisplayObject to mangle		 */		public static function fixRegistrationPoint(d:DisplayObject):void {			var tempParent:Sprite;			if (!d.parent) {				tempParent = new Sprite();				tempParent.addChild(d);			}						var r:Rectangle = d.getBounds(d.parent);			var xOffset:Number = d.x - r.x;			var yOffset:Number = d.y - r.y;						var dc:DisplayObjectContainer = d as DisplayObjectContainer;			if (dc) {				for (var i:uint = 0; i < dc.numChildren; ++i) {					var d2:DisplayObject = dc.getChildAt(i);					d2.x += xOffset;					d2.y += yOffset;				}			} else {				d.x += xOffset;				d.y += yOffset;			}						if (tempParent) {				tempParent.removeChild(d);			}		}								/**		 * Traces errors relating to missing frame labels to the console.		 * 		 * @param mc MovieClip to do a search for frame labels on		 * @param labels Set of labels to search for		 *		 * @return an associative array where key is label and value is true if label was found and false if it was not		 */		public static function findTimelineLabels(mc:MovieClip, labels:Array):Object {						var timelineLabelsResult:Object = new Object();			for( var i:uint = 0; i < labels.length; i++ )				timelineLabelsResult[labels[i]] = false;						var flArray:Array = mc.currentLabels;			for( var j:uint = 0; j < flArray.length; j++ ) {							for( var k:uint = 0; k < labels.length; k++ ) {					if( flArray[j].name == labels[k] ) {						timelineLabelsResult[labels[k]] = true;						break;					}				}							}						return timelineLabelsResult;		}					/**		 * Traces errors relating to missing frame labels to the console.		 * 		 * @param timelineLabelsResult result from findTimelineLabels		 * @param labels Set of labels to look for		 * @param messageBeforeLabel String to prepend to each error		 * @param messageAfterLabel String to append to each error		 * 		 * @return true if error		 */		public static function traceMissingLabelsErrors(			timelineLabelsResult:Object,			labels:Array,			messageBeforeLabel:String = "Expecting the ",			messageAfterLabel:String = " frame label"		):Boolean {			var areThereMissingLabels:Boolean = false;						for( var i:uint = 0; i < labels.length; i++ ) {				if( !timelineLabelsResult[labels[i]] ) {					areThereMissingLabels = true;					trace(messageBeforeLabel+labels[i]+messageAfterLabel);				}			}						return areThereMissingLabels;					}								/**		 * Swaps coordinates from one coordinate system to another.		 */		public static function localToLocal(from:DisplayObject, to:DisplayObject, p:Point):Point {			return to.globalToLocal(from.localToGlobal(p));		}				/**		 * Moves d to the same position in newParent.		 */		public static function reparent(d:DisplayObject, newParent:DisplayObjectContainer):void {			if (d.parent) {				var p:Point = localToLocal(d.parent, newParent, new Point(d.x, d.y));				d.x = p.x;				d.y = p.y;				d.parent.removeChild(d);			}						newParent.addChild(d);		}	}}