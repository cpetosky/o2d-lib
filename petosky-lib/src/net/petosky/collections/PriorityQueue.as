package net.petosky.collections {	import flash.errors.IllegalOperationError;			/**	 * A PriorityQueue is a queue in which the elements are sorted by some	 * property. Only the element with the lowest (or highest) property value	 * is accessible.	 * 	 * @author cpetosky	 */	public class PriorityQueue implements IPriorityQueue {		private var _list:Array;		private var _sortProperty:String;		private var _ascending:Boolean;				private var _comparator:Function;				/**		 * Creates a new PriorityQueue.		 * 		 * @param sortProperty The property of the objects to sort on. Every		 *        object in the queue must have this property.		 * @param ascending If true, the lowest priority element is at the head		 */		public function PriorityQueue(sortProperty:String, ascending:Boolean = true) {			_list = new Array();			_sortProperty = sortProperty;			this.ascending = ascending;		}				/**		 * Removes all elements from this priority queue.		 */		public function clear():void {			_list = [];		}								/**		 * Use push instead.		 * 		 * @deprecated		 * @see push		 */		public function enqueue(o:Object):Boolean {			return push(o);		}						/**		 * Add a single object to this queue.		 * 		 * @param o object to add		 */		public function push(o:Object):Boolean {			if (_list.length == 0)				_list = [o];			else {				for (var i:uint = 0; i < _list.length; ++i) {					if (_comparator(o, _list[i])) {						_list.splice(i, 0, o);						return true;					}				}				_list.push(o);			}			return true;		}										public function enqueueArray(a:Array):Boolean {			return pushArray(a);		}				public function pushArray(a:Array):Boolean {			var b:Boolean = true;						for each (var o:* in a)				b = b && enqueue(o);						return b;					}				/**		 * Removes and returns the head of the queue.		 * 		 * @return head of queue		 */		public function pop():Object {			if (empty)				throw new IllegalOperationError("[PriorityQueue.peek] Cannot dequeue from queue of length 0!");						return _list.shift();		}		public function dequeue():Object {			return pop();		}								/**		 * Returns, but does not remove, the head of the queue.		 * 		 * @return head of queue		 */		public function peek():Object {			if (empty)				throw new IllegalOperationError("[PriorityQueue.peek] Cannot peek queue of length 0!");			return _list[0];		}								/**		 * Enqueues all arguments.		 * 		 * @see enqueue		 */		public function add(...args):Boolean {			return addArray(args);		}								/**		 * Enqueues an array of arguments.		 * 		 * @see enqueueArray		 */		public function addArray(a:Array):Boolean {			for (var i:uint = 0; i < a.length; ++i)				enqueue(a[i]);			return true;		}								/**		 * Returns a string representation of this priority queue, in order.		 */		public function toString():String {			return _list.toString();		}								/**		 * Returns a sorted array containing all elements in this queue.		 */		public function toArray():Array {			return _list.concat();		}								/**		 * The number of elements in this queue.		 */		public function get length():uint {			return _list.length;		}								/**		 * True if the queue contains zero elements.		 */		public function get empty():Boolean {			return (_list.length == 0);		}								/**		 * The property to sort on. All elements in queue must contain this		 * property.		 */		public function get sortProperty():String {			return _sortProperty;		}		public function set sortProperty(value:String):void {			_sortProperty = value;		}								/**		 * If true, element with lowest priority is at the head of the queue.		 */		public function get ascending():Boolean {			return _ascending;		}		public function set ascending(value:Boolean):void {			_ascending = value;			setComparator();		}		/**		 * If true, element with highest priority is at the head of the queue.		 */		public function get descending():Boolean {			return !_ascending;		}		public function set descending(value:Boolean):void {			_ascending = !value;			setComparator();		}				private function setComparator():void {			if (_ascending)				_comparator = compareAscending;			else				_comparator = compareDescending;		}				private function compareAscending(o1:*, o2:*):Boolean {			return o1[_sortProperty] < o2[_sortProperty];		}				private function compareDescending(o1:*, o2:*):Boolean {			return o1[_sortProperty] > o2[_sortProperty];		}
		
		
		
	}}