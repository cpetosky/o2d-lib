package net.petosky.xml.style {	import net.petosky.util.StringUtils;		import net.petosky.xml.Element;			import flash.text.StyleSheet;				/**	 * A CascadingStyleSheet provides functionality similar to a StyleSheet --	 * that is, both classes wrap CSS formatting for Flash. However, a	 * CascadingStyleSheet goes well beyond the default functionality provided	 * by Flash.	 * 	 * A CascadingStyleSheet can parse any allowable selector type, including	 * descendant selectors ("div ul"), child selectors ("div > li"), and	 * psuedo-selectors ("a:before"). A CascadingStyleSheet can be read by a	 * DocumentRenderer in order to format an XML document with this expanded	 * CSS.	 * 	 * Note that even though CascadingStyleSheet supports parsing all	 * valid CSS, it doesn't actually support calculation and cascading of more	 * complicated properties. For now, the following constructs are supported:	 * 	 * ID selectors (#header)	 * Class selectors (.content)	 * Element selectors (div)	 * 	 * Parent inheritance is also supported, but can be disabled by	 * setting enableParentInheritance to false.	 * 	 * CascadingStyleSheet extends StyleSheet, but only to trick Flash into	 * doing some work for it. Do not treat instances of this class as	 * regular StyleSheets.	 * 	 * @author cpetosky	 * 	 * @see Document	 * @see DocumentRenderer	 */	public dynamic class CascadingStyleSheet extends StyleSheet {		public static var enableParentInheritance:Boolean = true;				private var _css:String = "";						override public function parseCSS(css:String):void {			css = StringUtils.trim(stripComments(css));			_css += css;			var a:Array = css.split("}");			for each (var s:String in a) {				if (s == "")					continue;				var b:Array = s.split("{");				var selector:String = StringUtils.trim(b[0]);				if (this[selector]) {					this[selector].append(StringUtils.trim(b[1]));				} else {					this[selector] = new Style(StringUtils.trim(b[1]));				}			}						super.parseCSS(css);		}				private function stripComments(css:String):String {			css = css.replace(/\/\*.*?\*\/\n?/gs, "");			css = css.replace(/\/\/.*/g, "");						return css;		}				/**		 * Create a new sheet based on the cascade from this sheet to the		 * provided argument. The provided sheet's properties override this		 * one's when two identical properties are found.		 * 		 * @param s child style sheet		 * @return new style sheet based upon these two		 */		public function asParentOf(s:CascadingStyleSheet):CascadingStyleSheet {			var newSheet:CascadingStyleSheet = new CascadingStyleSheet();			newSheet.parseCSS(_css);			newSheet.parseCSS(s._css);			return newSheet;		}		/**		 * Removes all selectors from this style sheet.		 */		override public function clear():void {			super.clear();			for( var selector:String in this ) {				delete this[selector];			}		}		/**		 * Return the style object that corresponds to the element		 * provided. This style object is the result of all inheritance		 * and cascading within the style sheet.		 * 		 * @param e element to style		 * @return style of the element provided		 */		public function generateStyle(e:Element):Style {			var s:Style = new Style();						// Simple ID and class selection			if (e.id)				getStyleByID(e.id).offerValuesTo(s);			if (e["class"])				getStyleByClass(e["class"]).offerValuesTo(s);							// Simple tag-name selection			getCurrentElementStyle(e).offerValuesTo(s);						// Perform parent-element inheritance			if (enableParentInheritance && e.parent != null)							generateStyle(e.parent).offerInheritableValuesTo(s);							// Apply default styles			StyleParser.get().defaultStyle.offerValuesTo(s);						return s;		}				private function getStyleByID(id:String):Style {			if (this["#" + id])				return this["#" + id];			else				return new Style();		}				private function getStyleByClass(klass:String):Style {			if (this["." + klass])				return this["." + klass];			else				return new Style();		}				private function getCurrentElementStyle(e:Element):Style {			if (this[e.name])				return this[e.name].clone();			else				return new Style();		}				/**		 * Return a string representation of this stylesheet that looks similar		 * to, but not exactly like, a traditional stylesheet.		 */		override public function toString():String {			var s:String = "";			for (var selector:String in this) {				s += selector + " {\n";				for (var rule:String in this[selector]) {					s += "    " + rule + ": " + this[selector][rule] + ";\n";				}				s += "}\n\n";			}			return s;		}	}}