package net.petosky.xml.style {	import flash.errors.IllegalOperationError;		import net.petosky.util.ArrayUtils;		/**	 * A StyleParser provides extensible CSS style parsing functionality.	 * It comes with a set of standard CSS mechanisms (provided by	 * StandardParserPlugin), but can be extended by creating a custom instance	 * of IStyleParserPlugin and providing it to the addPlugin function.	 *  	 * @author cpetosky	 * 	 * @see IStyleParserPlugin	 */	public class StyleParser {		private static var __instance:StyleParser;		public static function get():StyleParser {			if (__instance == null)				__instance = new StyleParser(new SingletonEnforcer());			return __instance;		}				private var _plugins:Array = new Array();		private var _parsers:Object = new Object();		private var _shorthands:Object = new Object();		private var _defaults:Object = new Object();		private var _inheritable:Object = new Object();				private var _defaultStyle:Style;				public function StyleParser(enforcer:SingletonEnforcer) {			if (enforcer == null)				throw new IllegalOperationError("[StyleParser.iinit] This class cannot be instantiated.");			addPlugin(new StandardParserPlugin());			addPlugin(new FlashExtensionsParserPlugin());		}				public function addPlugin(plugin:IStyleParserPlugin):void {			_parsers = ArrayUtils.mergeObjects(_parsers, plugin.parsers);			_shorthands = ArrayUtils.mergeObjects(_shorthands, plugin.shorthands);			_defaults = ArrayUtils.mergeObjects(_defaults, plugin.defaults);						for each (var s:String in plugin.inheritables)				_inheritable[s] = true;						_defaultStyle = null;			_plugins.push(plugin);		}				private function generateDefaultStyle():void {			_defaultStyle = new Style();			for (var key:String in _defaults)				_defaultStyle[key] = _defaults[key];		}		public function parseAndMerge(name:String, value:String, store:Object):void {			if (_parsers[name]) { // if a parser exists				var val:* = _parsers[name](value); // parse the value				if (_shorthands[name]) // if a shorthand exists					for (var key:String in _shorthands[name]) // for each shorthand property						if (key == name) // if referring to itself							store[key] = val[_shorthands[name][key]]; // directly set the property						else // if not referring to itself							parseAndMerge(key, val[_shorthands[name][key]], store); // recursively parse the shorthand property				else // if no shorthand exists					store[name] = val; // directly set the property			} else // if no parser exists				store[name] = value; // directly set the property		}				public function get defaultStyle():Style {			if (_defaultStyle == null)				generateDefaultStyle();			return _defaultStyle;		}				public function inheritable(property:String):Boolean {			return _inheritable[property] != undefined;		}	}}class SingletonEnforcer { }