package net.petosky.xml.style {	/**	 * A StyleParserPlugin is used to extend CSS parsing functionality.	 * 	 * CSS consists of properties. Many properties are strings and can	 * be used directly with no pre-processing. However, most properties	 * require some sort of pre-processing to be useful.	 * 	 * The parsers object below is the primary mechanism for this.	 * 	 * One can list a CSS property and its corresponding parser in this	 * object. Whenever an attempt is made to set that property on the	 * Style object, the parser is invoked on the requested value.	 * The parser returns the processed value, which is then set into the	 * style.	 * 	 * This implies the following signature for any parser function:	 * 	 * function parse(s:String):*	 * 	 * That said, functions that appear to have that signature are also	 * permitted. For example, the parseInt function	 * 	 * function parseInt(s:String, radix:int = 10):int	 * 	 * is acceptable because it can be called as if it only took a single	 * String parameter.	 * 	 * 	 * Finally, CSS has the notion of property shorthands. For example, the	 * "padding" property is really shorthand for setting "padding-top",	 * "padding-right", "padding-bottom", and "padding-left" in a single	 * declaration. The parsing engine supports defining these shorthand	 * properties.	 * 	 * After a property is parsed by its specified parser, the engine looks	 * to see if a shorthand specification exists for that property. If it	 * does, other properties are set based upon the parsed value set in the	 * CSS. The object entry in the shorthands array specifies how to use	 * the value. Each key in the object refers to another CSS property.	 * The value must be a string -- this string is the name of a property in	 * the parsed value to assign to the CSS property referred to by the key	 * of the object in the shorthands array.	 * 	 * Because this is confusing, I provide an example below.	 * 	 * Here's the scenario:	 * 	 * parsers = {	 *     padding: function(s:String):Object {	 *         var a:Array = s.split(" ");	 *         return {	 *             top: a[0],	 *             right: a[1],	 *             bottom: a[2],	 *             left: a[3]	 *         }	 *     },	 *     paddingTop: parseInt,	 *     paddingRight: parseInt,	 *     paddingBottom: parseInt,	 *     paddingLeft: parseInt	 * }	 * 	 * shorthands = {	 *     padding: {	 *         paddingTop: "top",	 *         paddingRight: "right",	 *         paddingBottom: "bottom",	 *         paddingLeft: "left"	 *     }	 * }	 * 	 * The following CSS property is encountered:	 * 	 * padding: 3 5 7 8;	 * 	 * Our source string is therefore "3 5 7 8".	 * First, the __parsers array is consulted, and __parsers.padding(source) is called.	 * This returns an object pValue: { top: "3", right: "5", bottom: "7", left: "8" }	 * Next, the __shorthands array is consulted. A "padding" property is found.	 * 	 * The property paddingTop = pValue.top	 * The property paddingRight = pValue.right	 * The property paddingBottom = pValue.bottom	 * The property paddingLeft = pValue.left	 * 	 * Note that this is recursive. That is, when paddingTop is assigned	 * the value pValue.top, we check if there's a parser for paddingTop	 * in the _parsers array. This parser returns the source string "3"	 * as the integer 3. Finally, we check for shorthands. There are none,	 * so the Style object's property called paddingTop is assigned the	 * integer 3 as its value. The other padding properties follow suit.	 * 	 * The following code snippet demonstrates this:	 * 	 * var s:Style = new Style();	 * s.padding = "3 5 7 8"	 * trace(s);  // shows paddingTop: 3, paddingRight: 5, paddingBottom: 7, paddingLeft: 8	 * 	 * Finally, one should note that the shorthands array can be used for more than	 * mere shorthand properties. It is especially useful for custom CSS properties.	 * For example, this extends backgroundColor to use a 4-byte ARGB string, creating	 * a custom backgroundAlpha property that ranges from 0 to 1, inclusive:	 * 	 * parsers = {	 *     backgroundAlpha: function(s:String):uint {	 *         return parseInt(s, 16) / 0xFF;	 *     },	 *     	 *     backgroundColor: function(s:String):Object {	 *         if (s.charAt() == "#") {	 *             var c:String;	 *             var a:String;	 *             s = s.substr(1);	 *             if (s.length == 3) {	 *                 c = s.charAt(0) + s.charAt(0) + s.charAt(1) + s.charAt(1) + s.charAt(2) + s.charAt(2);	 *                 a = "FF";	 *             } else if (s.length == 6) {	 *                 c = s;	 *                 a = "FF";	 *             } else if (s.length == 8) {	 *                 c = s.substr(2);	 *                 a = s.substr(0, 2);	 *             } 	 *                	 *            	 *             return {	 *                 color: parseInt(c, 16),	 *                 alpha: a	 *             };	 *         }	 *     }	 * }	 * 	 * shorthands = {	 *     backgroundColor: {backgroundColor: "color", backgroundAlpha: "alpha" }	 * }	 * 	 * In the special case where a shorthand property contains a key with its own	 * name, further recursion and parsing (on that property only) is skipped and	 * the property is directly assigned. This is never the case with standard	 * CSS properties, but is often convenient for custom ones.	 */	public interface IStyleParserPlugin {		function get author():String;		function get version():String;				function get parsers():Object;		function get shorthands():Object;		function get defaults():Object;		function get inheritables():Array;			}}