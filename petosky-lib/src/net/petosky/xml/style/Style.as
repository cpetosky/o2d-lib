package net.petosky.xml.style {	import net.petosky.util.StringUtils;			import flash.utils.Proxy;	import flash.utils.flash_proxy;		/**	 * A Style is a collection of CSS properties. They are usually generated	 * by parsing CSS with a CascadingStyleSheet. A StyleParser and its plugins	 * provide the actual parsing mechanism.	 * 	 * This class is dynamic and supports direct access of properties. For	 * example:	 * 	 * var s:Style = new Style("font-size: 16px;");	 * trace(s.fontSize); // Outputs "16"	 * 	 * Also note that data is generally typed as you'd expect.	 * 	 * var i:int = s.fontSize; // Works fine with no cast!	 * 	 * @author cpetosky	 * 	 * @see CascadingStyleSheet	 * @see StyleParser	 */	public dynamic class Style extends Proxy {		private var _obj:Object = new Object();		private var _keys:Array;		private var _values:Array;				private var _parser:StyleParser;		/**		 * Create a new style. Optionally provide some properties to initialize		 * it with.		 * 		 * @param data CSS properties to add to this style.		 */		public function Style(data:String = "") {			_parser = StyleParser.get();			append(data);		}				/**		 * @return a copy of this style.		 */		public function clone():Style {			var s:Style = new Style();			for (var key:String in _obj)				s._obj[key] = _obj[key];			return s;		}		/**		 * Include the CSS properties provided into the existing properties in		 * this style.		 * 		 * @param data the additional CSS to include 		 */		public function append(data:String):void {			var a:Array = data.split(";");			for each (var s:String in a) {				if (s == "")					continue;				var b:Array = s.split(":");				var rule:String = modifyRuleName(StringUtils.trim(b[0]));				this[rule] = StringUtils.trim(b[1]);			}		}				/**		 * Put values from this style into the provided style, but only if		 * they don't already have values there.		 * 		 * @param s the style to accept the values		 */		public function offerValuesTo(s:Style):void {			for (var key:String in _obj)				if (s._obj[key] == undefined)					s._obj[key] = _obj[key];		}				/**		 * Put values from this style into the provided style, but only if		 * they don't already have values there and the property values are		 * inheritable.		 * 		 * @param s the style to accept the values		 */		public function offerInheritableValuesTo(s:Style):void {			for (var key:String in _obj)				if (s._obj[key] == undefined && _parser.inheritable(key))					s._obj[key] = _obj[key];		}				/**		 * Put values from this style into the provided style, overwriting		 * identical properties if present.		 * 		 * @param s the style to accept the values		 */		public function forceValuesOn(s:Style):void {			for (var key:String in _obj)				s._obj[key] = _obj[key];		}				private static function modifyRuleName(rule:String):String {			var p:int;			while ((p = rule.indexOf("-")) >= 0) {				rule = rule.substr(0, p) + rule.charAt(p + 1).toUpperCase() + rule.substr(p + 2);			}				return rule;		}				/**		 * @return a string that looks somewhat like a CSS property list.		 */		public function toString():String {			var s:String = "";			for (var key:String in _obj) {				s += key + ":" + _obj[key] + ", ";			}			return s.substr(0, s.length - 2);		}				/**		 * @private		 */		override flash_proxy function setProperty(name:*, value:*):void {			_parser.parseAndMerge(name, value, _obj);		}				/**		 * @private		 */		override flash_proxy function getProperty(name:*):* {			return _obj[name];		}				/**		 * @private		 */		override flash_proxy function nextNameIndex(i:int):int {			if (i == 0) {				_keys = new Array();				_values = new Array();				for (var key:String in _obj) {					_keys.push(key);					_values.push(_obj[key]);				}			}						if (i < _keys.length)				return i + 1;			else				return 0;		}				/**		 * @private		 */		override flash_proxy function nextName(index:int):String {			return _keys[index - 1];		}				/**		 * @private		 */		override flash_proxy function nextValue(index:int):* {			return _values[index - 1];		}	}}