package net.petosky.xml {	import net.petosky.util.StringUtils;		import net.petosky.xml.style.Style;		import net.petosky.xml.style.CascadingStyleSheet;			import flash.text.AntiAliasType;	import flash.text.TextFieldAutoSize;	import flash.text.GridFitType;		import flash.text.TextFormat;			import flash.text.TextFieldType;		import flash.text.TextField;		import flash.display.DisplayObject;			import flash.display.Sprite;		/**	 * @author cpetosky	 */	public class ElementRenderer extends Sprite {		private var _element:Element;		private var _styleSheet:CascadingStyleSheet;		private var _style:Style;				private var _content:Sprite = new Sprite();		public function ElementRenderer(element:Element, styleSheet:CascadingStyleSheet, maxWidth:int) {			_element = element;			_styleSheet = styleSheet;			_style = _styleSheet.generateStyle(element);			render(maxWidth);		}				public function render(maxWidth:int):void {			var localY:int = 0;						// handle top and left margin and padding offsets			_content.y += _style.marginTop;			_content.x += _style.marginLeft;			_content.y += _style.paddingTop;			_content.x += _style.paddingLeft;			maxWidth -= _style.marginLeft + 						_style.marginRight + 						_style.paddingLeft +						_style.paddingRight /*+						(_style.borderLeftStyle == "none" ? 0 : _style.borderLeftWidth) +						(_style.borderRightStyle == "none" ? 0 : _style.borderRightWidth)*/;							addChild(_content);						// Render each child			for (var i:uint = 0; i < _element.numChildren; ++i) {				var node:Node = _element.child(i);				var d:DisplayObject;				switch (node.type) {					case NodeType.ELEMENT:						d = new ElementRenderer(node as Element, _styleSheet, _style.width as int || maxWidth);						break;					case NodeType.TEXT:						d = renderText((node as TextNode).text, maxWidth);						break;				}								d.y = localY;				localY += d.height;								_content.addChild(d);			}						graphics.clear();						// Draw background color			if (_style.backgroundColor) {				graphics.beginFill(_style.backgroundColor, _style.backgroundAlpha || 1);			} else {				// Draw transparent fill for padding				graphics.beginFill(0, 0);			}						graphics.drawRect(				_style.marginLeft,				_style.marginTop,				width + _style.paddingLeft + _style.paddingRight,				height + _style.paddingTop + _style.paddingBottom			);			graphics.endFill();													// Draw transparent fills for margin			var totalWidth:int = width + _style.marginLeft + _style.marginRight;			var totalHeight:int = height + _style.marginTop + _style.marginBottom;			graphics.beginFill(0, 0);			if (_style.marginTop > 0)				graphics.drawRect(0, 0, totalWidth, _style.marginTop);			if (_style.marginBottom > 0)				graphics.drawRect(0, height + _style.marginTop, totalWidth, _style.marginBottom);			if (_style.marginLeft > 0)				graphics.drawRect(0, 0, _style.marginLeft, totalHeight);			if (_style.marginRight > 0)				graphics.drawRect(width + _style.marginLeft, 0, _style.marginRight, totalHeight);							graphics.endFill();						// Apply filters			var f:Array = filters;						if (_style.filterBevel)				f.push(_style.filterBevel);			if (_style.filterBlur)				f.push(_style.filterBlur);			if (_style.filterDropShadow)				f.push(_style.filterDropShadow);			if (_style.filterGlow)				f.push(_style.filterGlow);							filters = f;		}				private function renderText(s:String, maxWidth:int):DisplayObject {			var tf:TextField = new TextField();			tf.embedFonts = true;			tf.antiAliasType = AntiAliasType.ADVANCED;			if (_style.textAlign == "left")				tf.gridFitType = GridFitType.PIXEL;			else				tf.gridFitType = GridFitType.SUBPIXEL;			tf.type = TextFieldType.DYNAMIC;						// Apply formatting			var format:TextFormat = tf.defaultTextFormat;			format.color = _style.color;			format.font = _style.fontFamily;			format.size = _style.fontSize;			format.align = _style.textAlign;			format.leading = _style.leading;			format.kerning = _style.kerning;			format.bold = _style.fontWeight == "bold";			format.italic = _style.fontStyle == "italic";			format.underline = _style.textDecoration == "underline";			format.letterSpacing = _style.letterSpacing;			format.indent = _style.textIndent;						tf.defaultTextFormat = format;			tf.styleSheet = _styleSheet;			tf.multiline = _style.multiline;			tf.wordWrap = _style.multiline;			tf.autoSize = TextFieldAutoSize.LEFT;			tf.selectable = false;						if(_style.multiline) tf.width = maxWidth;			if (_style.lineHeight is int)				s = enforceLineHeight(s, _style.lineHeight);			s = applyTextTransform(s, _style.textTransform);			tf.htmlText = s;						// Layout text block			if (_style.width is int && _style.multiline) {				tf.width = _style.width;				//tf.height = tf.textHeight + 5;			} else if (_style.width == "auto") {				//tf.height = tf.textHeight + 5;			}						tf.alpha = _style.alpha;			return tf;		}				private function enforceLineHeight(s:String, height:uint):String {			var r:String = "";						_styleSheet.parseCSS(".line-height-" + height + " { font-size: " + height + "px; }");						var tag:String = '<span class="line-height-' + height + '"> </span>';						var a:Array = s.split("<");			for (var i:uint = 0; i < a.length; ++i) {				if (a[i].length == 0)					continue;				var b:Array = a[i].split(">");				if (b.length == 1)					r += a[i].replace(/ /g, tag);				else					r += "<" + b[0] + ">" + b[1].replace(/ /g, tag);			}			return r;		}				private function applyTextTransform(s:String, mode:String):String {						if (mode == "none")				return s;			var tag:String = '';						if (mode == "smallcaps") {				tag = '<span class="small-caps-' + _style.fontSize + '">$&</span>';								_styleSheet.parseCSS(".small-caps-" + _style.fontSize + " { font-size: " + (int)(_style.fontSize * 0.75) + "px; }");			}						var r:String = "";			var a:Array = s.split("<");			for (var i:int = 0; i < a.length; ++i) {				if (a[i].length == 0)					continue;				var b:Array = a[i].split(">");				switch (mode) {					case "capitalize":						if (b.length == 1)							r += StringUtils.toTitleCase(a[i]);						else							r += "<" + b[0] + ">" + StringUtils.toTitleCase(b[1]);						break;					case "uppercase":						if (b.length == 1)							r += a[i].toUpperCase();						else							r += "<" + b[0] + ">" + b[1].toUpperCase();						break;					case "lowercase":						if (b.length == 1)							r += a[i].toLowerCase();						else							r += "<" + b[0] + ">" + b[1].toLowerCase();						break;					case "smallcaps":/*						if (b.length == 1)							r += a[i].replace(new RegExp('[a-z]*', 'g'), tag);						else							r += "<" + b[0] + ">" + b[1].replace(new RegExp('[a-z]*', 'g'), tag);*/					default:				}			}						return r;		}	}}